$date
	Tue Mar 12 15:16:32 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module four_bit_reg_top $end
$scope module four_bit_reg $end
$var wire 1 ! clk $end
$var wire 4 " d [3:0] $end
$var wire 1 # enable $end
$var wire 4 $ q [3:0] $end
$var wire 1 % reset $end
$var wire 4 & s8 [3:0] $end
$var wire 1 ' s7 $end
$var wire 1 ( s6 $end
$var wire 1 ) s5 $end
$var wire 1 * s4 $end
$var wire 1 + s3 $end
$var wire 1 , s2 $end
$var wire 1 - s1 $end
$var wire 1 . s0 $end
$var wire 4 / q_temp [3:0] $end
$scope module DIG_D_FF_AS_1bit_i0 $end
$var wire 1 ! C $end
$var wire 1 % Clr $end
$var wire 1 . D $end
$var wire 1 - Q $end
$var wire 1 0 Set $end
$var wire 1 1 \~Q $end
$var reg 1 2 state $end
$upscope $end
$scope module DIG_D_FF_AS_1bit_i1 $end
$var wire 1 ! C $end
$var wire 1 % Clr $end
$var wire 1 , D $end
$var wire 1 + Q $end
$var wire 1 3 Set $end
$var wire 1 4 \~Q $end
$var reg 1 5 state $end
$upscope $end
$scope module DIG_D_FF_AS_1bit_i2 $end
$var wire 1 ! C $end
$var wire 1 % Clr $end
$var wire 1 * D $end
$var wire 1 ) Q $end
$var wire 1 6 Set $end
$var wire 1 7 \~Q $end
$var reg 1 8 state $end
$upscope $end
$scope module DIG_D_FF_AS_1bit_i3 $end
$var wire 1 ! C $end
$var wire 1 % Clr $end
$var wire 1 ( D $end
$var wire 1 ' Q $end
$var wire 1 9 Set $end
$var wire 1 : \~Q $end
$var reg 1 ; state $end
$upscope $end
$scope module four_bit_mux_i4 $end
$var wire 4 < a [3:0] $end
$var wire 4 = b [3:0] $end
$var wire 1 # sel $end
$var wire 4 > y [3:0] $end
$var wire 1 ? s9 $end
$var wire 1 @ s8 $end
$var wire 1 A s7 $end
$var wire 1 B s6 $end
$var wire 1 C s5 $end
$var wire 1 D s4 $end
$var wire 1 E s3 $end
$var wire 1 F s2 $end
$var wire 1 G s11 $end
$var wire 1 H s10 $end
$var wire 1 I s1 $end
$var wire 1 J s0 $end
$scope module two_bit_mux_i0 $end
$var wire 1 D a $end
$var wire 1 @ b $end
$var wire 1 # s $end
$var wire 1 J y $end
$upscope $end
$scope module two_bit_mux_i1 $end
$var wire 1 B a $end
$var wire 1 H b $end
$var wire 1 # s $end
$var wire 1 F y $end
$upscope $end
$scope module two_bit_mux_i2 $end
$var wire 1 C a $end
$var wire 1 ? b $end
$var wire 1 # s $end
$var wire 1 I y $end
$upscope $end
$scope module two_bit_mux_i3 $end
$var wire 1 A a $end
$var wire 1 G b $end
$var wire 1 # s $end
$var wire 1 E y $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0J
0I
0H
0G
0F
0E
0D
0C
0B
0A
0@
0?
b0 >
b0 =
b0 <
0;
1:
09
08
17
06
05
14
03
02
11
00
b0 /
0.
0-
0,
0+
0*
0)
0(
0'
b0 &
1%
b0 $
0#
b0 "
0!
$end
#5
1!
#10
0%
0!
#15
1!
#20
1H
1G
b11 "
b11 =
0!
#25
1!
#30
1*
1(
1F
b11 &
b11 >
1E
1#
0!
#35
07
1B
0:
1A
1)
18
b11 $
b11 /
b11 <
1'
1;
1!
#40
1*
1(
1F
b11 &
b11 >
1E
1@
1?
b1111 "
b1111 =
0#
0!
#45
1!
#50
0?
0H
0G
b1000 "
b1000 =
0!
#55
1!
#60
0*
0(
0F
b0 &
b0 >
0E
17
0B
1:
0A
0)
08
b0 $
b0 /
b0 <
0'
0;
1%
0!
#65
1!
#70
1,
1*
1(
1I
1F
1E
1.
b1111 &
b1111 >
1J
1?
1H
1G
b1111 "
b1111 =
1#
0%
0!
#75
01
1D
04
1C
07
1B
0:
1A
1-
12
1+
15
1)
18
b1111 $
b1111 /
b1111 <
1'
1;
1!
#80
11
0D
14
0C
17
0B
1:
0A
0-
02
0+
05
0)
08
b0 $
b0 /
b0 <
0'
0;
0.
0*
0,
0(
0J
0F
0I
b0 &
b0 >
0E
0@
0?
0H
0G
b0 "
b0 =
0#
1%
0!
